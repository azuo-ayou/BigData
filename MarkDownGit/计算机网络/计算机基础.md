### 网络分层

1. 物理层
2. 链路层
3. 网络层 ip、ARP
4. 传输层 TCP、UDP
5. 会话层、表示层、应用层 ： FTP｜DNS 、HTTP、SMTP、HTTPS

### http版本比较

- 0.9 只允许客户端发送GET这一种请求，且不支持请求头。由于没有协议头，事件都是单独的，建立TCP链接，请求返回结果，没结果也不会有错误码，结束了就释放链接，
- 1.0 请求与响应支持头域
  - 响应对象以一个响应状态行开始
  - 响应对象不只限于超文本
  - 开始支持客户端通过POST方法向Web服务器提交数据，支持HEAD、POST方法
  - （短连接）每一个请求建立一个TCP连接，请求完成后立马断开连接。这将会导致2个问题：连接无法复用，head of line blocking。连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类请求影响较大。head of line blocking会导致带宽无法被充分利用，以及后续健康请求被阻塞。
- 1.1 keepalive连接，允许HTTP设备在事务处理结束之后将TCP连接保持在打开的状态，以便未来的HTTP请求重用现在的连接，直到客户端或服务器端决定将其关闭为
  - 该编码将实体分块传送并逐块标明长度，直到长度为0块表示传输结束
  -  新增了请求方式PUT、PATCH、OPTIONS、DELETE等。
- 2.0 
  - **二进制协议：** HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制
  - HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"
  - HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）





1. 09 只有get、没有请求头，短链接、没有返回码
2. 1.0 短链接 ，加了post、head等方法
3. 1.1 支持长链接，一次链接可以发送多个请求
4. 2.0 基于二进制的，长链接，多路复用，有服务器推送，header压缩









### https如何保证数据安全的

tcp+ssl

1. 建立tcp链接
2. 客户端向服务端发送请求，请求证书
3. 服务端发送带有公钥信息的证书
4. 客户端向证书机构验证证书，并且提取公钥
5. 客户端生成密钥，加密后发给服务端
6. 服务端返回收到请求



### http状态码

1. 信息，服务器收到请求，需要请求者继续执行操作
2. 成功，操作被成功接收并处理
3. 重定向，需要进一步的操作以完成请求
4. 客户端错误，请求包含语法错误或无法完成请求
5. 服务器错误，服务器在处理请求的过程中发生了错误



### http和https端口号 分别是 80 ： 443

Http:80

Https:443

Ftp:20/21

Smtp:25

DNS：53



### select poll epoll 

https://zhuanlan.zhihu.com/p/462924941

select 在维护多个描述的时候 底层是数组实现的，数组的大小是1024所以最多可以管理这么多的io,时间复杂度o(n)

poll 底层是用连表，理论上是没有大小限制的，时间复杂度o(n)

epoll 时间复杂度o(1), epoll只会返回有事件发生的描述符,不需要遍历所有的描述符。epoll_wait(),

水平触发（默认）：（LT），调用epoll_wait(),，监测到描述符到达事件就通知进程，进行可以不处理，下次调用epoll_wait()再次通知

边沿触发：（ET），通知进程以后必须马上处理，减少触发次数









### TCP的可靠传输

1. 确认应答与序列号：用于检验
2. 超时重传：设定一个时间没有收到回复就重新发送，当连续收到三个确定回复的时候，不必等时间，立即重传
3. 连接管理：三次握手和四次挥手
4. 流量控制：TCP报文头部有一个16字节的窗口大小，根据这个值，用来改变自己的发送速度
5. 拥塞控制：慢启动，一个发送少量数据，指数增长到拥塞窗口大小，然后线性增长。一旦网路拥塞，就立马降低速度，然后慢慢启动，并且调低窗口的大小





get和post的区别，不看后悔一辈子的文章：[www.oschina.net/news/77354/http-get-post-different](https://www.oschina.net/news/77354/http-get-post-different#:~:text=最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。 ...,GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。2016年9月22日)

- GET 在浏览器回退时是无害的，而 POST 会再次提交请求。
- GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。
- GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。
- GET 请求只能进行 url 编码，而 POST 支持多种编码方式。
- GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。
- GET 请求在 URL 中传送的参数是有长度限制的，而 POST 么有。
- 对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。
- GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。
- GET 参数通过 URL 传递，POST 放在 Request body 中。



我的总结

- 参数位置：get是url，post是Request body 中，所以post更安全
- get参数有限制，post没有
- get会被浏览器缓存，post不会，回退以后会再次请求
- get只会产生一个数据包，服务器直接返回200，post将header和body分开，产生两个数据包，服务器先返回100，然后返回200
- get请求刷新服务器或者回退没有影响，post请求回退时会重新提交数据请求。